/*This file is prepared for Doxygen automatic documentation generation.*/
/*! \file *********************************************************************
 *
 * \brief AVR32 UC3 ISP boot.
 *
 * - Compiler:           IAR EWAVR32
 * - Supported devices:  All AVR32UC devices with an INTC module can be used.
 *
 * \author               Atmel Corporation: http://www.atmel.com \n
 *                       Support and FAQ: http://support.atmel.no/
 *
 ******************************************************************************/

/* Copyright (C) 2006-2008, Atmel Corporation All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name of ATMEL may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY AND
 * SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <avr32/io.h>
#include "conf_isp.h"


//! @{
//! \verbatim


  // Performs efficiently a bitwise logical Exclusive-OR between the specified
  // register and an immediate value of up to 32 bits. The result is stored in
  // the destination register.
eor_w\
  MACRO rd, imm
    IF (imm) & 0x0000FFFF
      eorl    rd, LWRD(imm)
    ENDIF
    IF (imm) & 0xFFFF0000
      eorh    rd, HWRD(imm)
    ENDIF
  ENDM

  // Moves efficiently an immediate value of up to 32 bits into a register.
mov_w\
  MACRO rd, imm
    IF (((-(1 << (21 - 1))) <= (imm)) && ((imm) <= ((1 << (21 - 1)) - 1))) ||\
       (((1 << 32) - (1 << (21 - 1))) <= (imm))
      mov     rd, imm
#if __CORE_REVISION__ >= 2
    ELSEIF !((imm) & 0x0000FFFF)
      movh    rd, HWRD(imm)
#endif
    ELSE
      mov     rd, LWRD(imm)
      orh     rd, HWRD(imm)
    ENDIF
  ENDM

  // Performs efficiently a bitwise logical OR between the specified register
  // and an immediate value of up to 32 bits. The result is stored in the
  // destination register.
or_w\
  MACRO rd, imm
    IF (imm) & 0x0000FFFF
      orl     rd, LWRD(imm)
    ENDIF
    IF (imm) & 0xFFFF0000
      orh     rd, HWRD(imm)
    ENDIF
  ENDM


  RSEG  SSTACK:DATA:NOROOT(2)


  RSEG  RESET:CODE:NOROOT(1)


  ALIGN 1

  // Reset vector: This must be linked @ 0x80000000.
  PUBLIC  __program_start
__program_start:
  rjmp    _evba

  ORG 0x00002000

  // Start of exception vector table: Unrecoverable exception.
  PUBLIC  _evba
_evba:
  rjmp    handle_unrecoverable_exception

  ALIGN 2

  // ISP version: This word must be at offset 0x00000004 relatively to the ISP
  // start address for all past, present and future versions of the ISP.
  PUBLIC  isp_version
isp_version:
  DC32  ISP_VERSION

handle_unrecoverable_exception:
  mfsr    r8, AVR32_SR
  bfextu  r8, r8, AVR32_SR_M_OFFSET, AVR32_SR_M_SIZE
  cp.w    r8, 001b
  breq    boot_supervisor_mode
  sub     r8, pc, $ - boot_supervisor_mode
  mov_w   r9, AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | (AVR32_SR_M_SUP << AVR32_SR_M_OFFSET)
  mov     sp, SFE(SSTACK) - 6 * 4
  pushm   r8-r9
  rete

boot_supervisor_mode:
  mov_w   r8, ISP_KEY_ADDRESS
  mov_w   r9, ISP_FORCE_ADDRESS
  mov_w   r10, AVR32_WDT_ADDRESS
  mov_w   r1, ISP_KEY_VALUE
  ld.w    r2, r9[0]
  mov_w   r3, ISP_FORCE_VALUE
  cp.w    r2, r3
  brne    start_program

start_loader:
  rcall   disable_wdt
  st.w    r8[0], r1

  // Set initial stack pointer.
  mov     sp, SFE(SSTACK)

  // Disable the exception processing.
  ssrf    AVR32_SR_EM_OFFSET

  // Set up EVBA so interrupts can be enabled.
  sub     r0, pc, $ - _evba
  mtsr    AVR32_EVBA, r0

  // Initialize segments.
  PUBLIC  ?need_segment_init
?need_segment_init:
  EXTERN  __segment_init
  rcall   __segment_init

  // Call the ISP main function, which must not return.
  EXTERN  main
  rcall   main

start_program:
  mov_w   r11, AVR32_PM_ADDRESS
  ld.w    r2, r11[AVR32_PM_RCAUSE]
  bld     r2, AVR32_PM_RCAUSE_WDT_OFFSET
  brcc    start_program_no_isp_key
  ld.w    r0, r8[0]
  cp.w    r0, r1
  brne    start_program_no_isp_key
  rcall   disable_wdt
  mov_w   r0, 0
  st.w    r8[0], r0
start_program_no_isp_key:
  mov_w   r0, AVR32_SR_GM_MASK | AVR32_SR_EM_MASK | (AVR32_SR_M_SUP << AVR32_SR_M_OFFSET)
  mtsr    AVR32_SR, r0
  REPTI   rd, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, sp, lr
    mov_w   rd, 0
  ENDR
  mtsr    AVR32_EVBA, r0
  mtsr    AVR32_COUNT, r0
  lddpc   pc, program_start_address

disable_wdt:
  mov_w   r2, AVR32_WDT_KEY_VALUE << AVR32_WDT_CTRL_KEY_OFFSET
  st.w    r10[AVR32_WDT_CTRL], r2
  eor_w   r2, AVR32_WDT_CTRL_KEY_MASK
  st.w    r10[AVR32_WDT_CTRL], r2
  mov     pc, lr


// Constant data area.

  ALIGN 2

program_start_address:
  DC32  PROGRAM_START_ADDRESS


  END


//! \endverbatim
//! @}
